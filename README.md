# 연산자 오버로딩

### 연산자 오버로딩이란
- 기본 타입이 아닌 클래스 타입, 즉 사용자 정의 타입에도 연산자를 사용할 수 있게 하는 문법
- 연산자를 사용하면 컴파일러 내부에 정의되지 않은 타입의 연산이 가능하여 코드의 직관성과 가독성을 좋게한다.

### 연산자 오버로딩 정의 및 사용하기
- pt.x = this->x + arg.x
- const 멤버 함수와 비 const 멤버 함수
- const 멤버 함수는 멤버 함수 내에서 객체의 멤버 변수를 변경하지 않는다는 것을 보장하는 함수이다.
- const 객체는 const 멤버 함수 호출만 할 수 있다.

### 단항 연산자 오버로딩
- 오버로딩이 가능한 연산자 : !  & ~ * + - ++ -- 

### 이항 연산자 오버로딩
- 오버로딩이 가능한 이항 연산자 : +  -  *  /  ==  !=  <  <=
- == 연산자 오버로딩 : 비교 연산으로 bool 타입
- != 연산자 오버로딩 : == 연산자를 이용해 쉽게 구현할 수 있다.

### 전역 함수를 이용한 연산자 오버로딩
- 멤버 함수를 이용한 연산자 오버로딩
- 전역 함수를 이용한 연산자 오버로딩
- 프렌드에는 함수 프렌드와 클래스 프렌드 두가지 있다.

### STL에 필요한 주요 연산자 오버로딩
- 함수 호출 연산자 오버로딩 () 연산자 : 1-10
- 배열 인덱스 연산자 오버로딩 [] 연산자 : 1-16, 1-17, 1-18
- 메모리 접근, 클래스 멤버 접근 연산자 오버로딩 *, -> 연산자 : 1-19, 1-20
- stl의 핵심 구요소이다.

### 타입 변환 연산자 오버로딩
- 생성자를 이용한 타입 변환 : 1-23, 1-24, 1-25
- explict point 생성자 : 생성자를 이용한 형변환을 의도하지 않는다면 자는 명시적 호출반 가능하도록 키워드를 지정한다.     
- 타입 변환 연산자 오버로딩을 이용한 타입 변환 : 1-26, 1-27
